name: Create Deployment PR

on:
  push:
    branches: [main]

concurrency:
  group: create-deploy-pr
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  id-token: write

env:
  DEPLOY_BRANCH: bot/deploy

jobs:
  prepare-deployment-branch:
    runs-on: ubuntu-latest

    outputs:
      sha_tag: ${{ steps.prepare-deployment-branch.outputs.sha_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Ensure remote deploy branch exists, create git sha tag
        id: prepare-deployment-branch
        shell: bash
        run: |
          set -euo pipefail
          if ! git ls-remote --exit-code --heads origin bot/deploy >/dev/null 2>&1; then
            git checkout -B bot/deploy origin/main
            git push origin bot/deploy
          fi
          echo "sha_tag=git-$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

  build-and-push-images:
    runs-on: ubuntu-latest
    needs: prepare-deployment-branch

    strategy:
      matrix:
        images:
          - { name: "api", stack: "dev", first_party: true, context: "./services/api" }
          - { name: "cloudbeaver-init", stack: "dev", first_party: true, context: "./services/cloudbeaver-init" }
          - { name: "cloudbeaver", stack: "dev", first_party: false, docker_image: "dbeaver/cloudbeaver:latest" }
          - { name: "tailscale-beacon", stack: "core", first_party: true, context: "./services/tailscale-beacon" }
          - { name: "github-runner", stack: "dev", first_party: false, docker_image: "myoung34/github-runner:latest" }

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}

      - name: Setup Pulumi
        uses: pulumi/setup-pulumi@v2

      - name: Authenticate Pulumi
        uses: pulumi/auth-actions@v1
        with:
          organization: tyler-s-hatch
          requested-token-type: urn:pulumi:token-type:access_token:personal
          scope: user:tyler-s-hatch

      - name: Get Pulumi stack outputs
        id: pulumi
        shell: bash
        working-directory: infra
        run: |
          set -euo pipefail
          REPO_URL=$(pulumi stack output --stack ${{ matrix.images.stack }} ${{ matrix.images.name }}-image-repo-url)
          echo "repo_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "repo_name=$(basename $REPO_URL)" >> $GITHUB_OUTPUT
          echo "role_arn=$(pulumi stack output --stack core main-prepare-deploy-role-arn)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.pulumi.outputs.role_arn }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Calculate first party image build context hash
        if: ${{ matrix.images.first_party }}
        id: tree-hash
        shell: bash
        run: |
          set -euo pipefail
          TREE_HASH=$(git rev-parse HEAD:${{ matrix.images.context }})
          echo "tree_hash=${TREE_HASH:0:12}" >> $GITHUB_OUTPUT
          echo $TREE_HASH

      - name: Check for existing first party image by tree tag
        if: ${{ matrix.images.first_party }}
        id: check
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ steps.pulumi.outputs.repo_name }}"
          TREE_TAG="${{ steps.tree-hash.outputs.tree_tag }}"

          if DIGEST=$(aws ecr describe-images \
              --repository-name "$REPO" \
              --image-ids imageTag="$TREE_TAG" \
              --query 'imageDetails[0].imageDigest' \
              --output text 2>/dev/null); then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
            echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push first party image
        if: ${{ matrix.images.first_party && steps.check.outputs.exists == 'false'}} 
        id: build
        uses: docker/build-push-action@v6
        env:
          BUILDKIT_PROGRESS: plain
        with:
          context: ${{ matrix.images.context }}
          push: true
          tags: |
            ${{ steps.pulumi.outputs.repo_url }}:${{ needs.prepare-deployment-branch.outputs.sha_tag }}
            ${{ steps.pulumi.outputs.repo_url }}:${{ steps.tree-hash.outputs.tree_hash }}
          cache-from: type=gha,scope=${{ matrix.images.name }}
          cache-to: type=gha,scope=${{ matrix.images.name }},mode=max
          provenance: false

      - name: Prepare lock fields (first party)
        if: ${{ matrix.images.first_party }}
        id: prep_lock_first
        shell: bash
        run: |
          set -euo pipefail
          KEY="${{ steps.pulumi.outputs.repo_name }}"

          if [ "${{ steps.check.outputs.exists }}" = "true" ]; then
            DIGEST="${{ steps.check.outputs.digest }}"
          else
            DIGEST="${{ steps.build.outputs.digest }}"
          fi

          SHA_TAG="${{ needs.prepare-deployment-branch.outputs.sha_tag }}"   # e.g., git-<sha>
          TREE_TAG="${{ steps.tree-hash.outputs.tree_hash }}"                 # e.g., tree-<hash>

          TAGS_JSON=$(jq -cn --arg a "$SHA_TAG" --arg b "$TREE_TAG" '[ $a, $b ]')
          TAGS_B64=$(printf %s "$TAGS_JSON" | base64 -w0 2>/dev/null || printf %s "$TAGS_JSON" | base64 | tr -d '\n')

          {
            echo "key=$KEY"
            echo "digest=$DIGEST"
            echo "tags_b64=$TAGS_B64"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare lock fields (third party)
        if: ${{ !matrix.images.first_party }}
        id: prep_lock_third
        shell: bash
        run: |
          set -euo pipefail
          LOCK="infra/image-lock.json"
          KEY="${{ steps.pulumi.outputs.repo_name }}"
          ECR_URL="${{ steps.pulumi.outputs.repo_url }}"

          if [ -f "$LOCK" ] && jq -e --arg k "$KEY" 'has($k) or (.repositories? and .repositories|has($k))' "$LOCK" >/dev/null 2>&1; then
            DIGEST="$(jq -r --arg k "$KEY" '
              if has($k) then .[$k].digest
              else .repositories[$k].digest
              end' "$LOCK")"
            TAGS_JSON="$(jq -c --arg k "$KEY" '
              if has($k) then .[$k].tags // []
              else .repositories[$k].tags // []
              end' "$LOCK")"
          else
            echo "Initializing lock for $KEY from ECR tag 'latest'â€¦"
            docker pull "$ECR_URL:latest"

            DETAILS="$(aws ecr describe-images \
              --repository-name "$KEY" \
              --image-ids imageTag=latest \
              --query 'imageDetails[0]' \
              --output json)"

            DIGEST="$(jq -r '.imageDigest // empty' <<< "$DETAILS")"
            TAGS_JSON="$(jq -c '.imageTags // []' <<< "$DETAILS")"
          fi

          TAGS_B64=$(printf %s "$TAGS_JSON" | base64 -w0 2>/dev/null || printf %s "$TAGS_JSON" | base64 | tr -d '\n')

          {
            echo "key=$KEY"
            echo "digest=$DIGEST"
            echo "tags_b64=$TAGS_B64"
          } >> "$GITHUB_OUTPUT"

      - name: Write lock snippet
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ matrix.images.name }}"
          KEY="${{ steps.prep_lock_first.outputs.key || steps.prep_lock_third.outputs.key }}"
          DIGEST="${{ steps.prep_lock_first.outputs.digest || steps.prep_lock_third.outputs.digest }}"
          TAGS_B64="${{ steps.prep_lock_first.outputs.tags_b64 || steps.prep_lock_third.outputs.tags_b64 }}"
          TAGS_JSON="$(echo "$TAGS_B64" | base64 -d 2>/dev/null || echo "$TAGS_B64" | base64 --decode 2>/dev/null)"

          jq -n --arg k "$KEY" --arg d "$DIGEST" --argjson tags "$TAGS_JSON" \
            '{($k): {digest:$d, tags:$tags}}' > "lock-${NAME}.json"

      - name: Upload lock snippet
        uses: actions/upload-artifact@v4
        with:
          name: lock-snippet-${{ matrix.images.name }}
          path: lock-${{ matrix.images.name }}.json

  generate-migrations-and-create-deploy-pr:

    runs-on: ubuntu-latest
    needs: build-and-push-images

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.DEPLOY_BRANCH }}

      - name: Reset deployment branch
        id: reset-deployment-branch
        shell: bash
        run: |
          set -euo pipefail
          git checkout -B "${{ env.DEPLOY_BRANCH }}" origin/"${{ github.ref_name }}"
          git reset --hard
          git clean -xfd

      # - name: Setup Pulumi
      #   uses: pulumi/setup-pulumi@v2

      # - name: Authenticate Pulumi
      #   uses: pulumi/auth-actions@v1
      #   with:
      #     organization: tyler-s-hatch
      #     requested-token-type: urn:pulumi:token-type:access_token:personal
      #     scope: user:tyler-s-hatch

      # - uses: pulumi/esc-action@v1
      #   id: esc
      #   with:
      #     environment: tyler-s-hatch/plerion/core

      # - name: Generate GitHub App Token
      #   id: generate_token
      #   uses: actions/create-github-app-token@v1
      #   with:
      #     app-id: ${{ steps.esc.outputs.github-app-id }}
      #     private-key: ${{ steps.esc.outputs.github-app-private-key }}

      # - name: Get Pulumi stack outputs
      #   id: pulumi-outputs
      #   working-directory: infra
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     echo "postgres_dsn_secret_arn=$(pulumi stack output --stack dev postgres-dsn-secret-arn)" >> $GITHUB_OUTPUT
      #     echo "role_arn=$(pulumi stack output --stack dev postgres-migrations-role-arn)" >> $GITHUB_OUTPUT

      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ steps.pulumi-outputs.outputs.role_arn }}
      #     aws-region: us-east-1 # TODO pull this from somewhere

      # - name: Fetch Postgres DSN secret
      #   id: get-postgres-dsn
      #   uses: aws-actions/aws-secretsmanager-get-secrets@v2
      #   with:
      #     secret-ids: POSTGRES_DSN,${{ steps.pulumi-outputs.outputs.postgres_dsn_secret_arn }}

      - name: Setup UV
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true
          cache-dependency-glob: |
            **/pyproject.toml
            **/uv.lock

      - name: Generate migration
        working-directory: services/api
        run: |
          export PICCOLO_CONF=src.db.local_conf
          uv sync --frozen
          uv run piccolo migrations new all --auto --auto_input=y || true

      - name: Download lock snippets
        uses: actions/download-artifact@v4
        with:
          pattern: lock-snippet-*
          merge-multiple: true
          path: .lock-snippets

      - name: Build image-lock.json
        run: |
          jq -s 'reduce .[] as $i ({}; . * $i)' .lock-snippets/*.json > infra/image-lock.json
          echo "Final lock file:"
          cat infra/image-lock.json

      - name: Create / update Deploy PR
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          branch: ${{ env.DEPLOY_BRANCH }}
          base: ${{ github.ref_name }}
          title: "Deploy (bot)"
          body: "Merging this PR will apply migrations and deploy infra/images."
          commit-message: "chore(deploy): update image-lock.json and migrations"
          add-paths: |
            infra/image-lock.json
            **/migrations/*.py
