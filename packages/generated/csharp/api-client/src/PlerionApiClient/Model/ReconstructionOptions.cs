/*
 * Plerion
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using FileParameter = PlerionApiClient.Client.FileParameter;
using OpenAPIDateConverter = PlerionApiClient.Client.OpenAPIDateConverter;

namespace PlerionApiClient.Model
{
    /// <summary>
    /// ReconstructionOptions
    /// </summary>
    [DataContract(Name = "ReconstructionOptions")]
    public partial class ReconstructionOptions
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconstructionOptions" /> class.
        /// </summary>
        /// <param name="randomSeed">Random seed to use (for deterministic behavior)..</param>
        /// <param name="singleThreaded">If true, run reconstruction in single-threaded mode (for deterministic behavior)..</param>
        /// <param name="neighborsCount">How many pose-nearest neighbors to consider when generating image pairs. Use -1 for exhaustive matching (all pairs). If None, a sensible default is used (currently 12). Smaller values reduce weak overlaps and speed up matching at the cost of some coverage..</param>
        /// <param name="rotationThreshold">Rotation angle threshold (degrees) for considering two images as neighbors when generating image pairs. Smaller values reduce weak overlaps and speed up matching at the cost of some coverage..</param>
        /// <param name="maxKeypointsPerImage">Upper bound on detected local features per image (SuperPoint). Reduces descriptor/match volume and downstream 3D points; too small can hurt registration..</param>
        /// <param name="ransacMaxError">Two-view RANSAC inlier threshold (pixels) used by verify_matches(). Lower &#x3D; stricter inlier test; removes borderline correspondences before SfM..</param>
        /// <param name="ransacMinInlierRatio">Two-view RANSAC minimum inlier ratio to accept the model. Higher &#x3D; reject more weak pairs; typically 0.10–0.20 for stricter matching..</param>
        /// <param name="usePriorPosition">If true, use position priors during registration. This leverages PosePrior(position&#x3D;...) written into the database to guide image registration..</param>
        /// <param name="rigVerification">If true, perform rig-based verification during feature matching and two-view geometry verification. Requires images to be tagged with rig/camera IDs..</param>
        /// <param name="triangulationMinimumAngle">Minimum triangulation angle (degrees). Applied at creation time (triangulation.min_angle) and again during mapper filtering (mapper.filter_min_tri_angle). Raising it removes low-parallax points..</param>
        /// <param name="triangulationCompleteMaxReprojectionError">Triangulation-time gate (pixels) for COMPLETING tracks into new 3D points (triangulation.complete_max_reproj_error). Lower → fewer borderline new points..</param>
        /// <param name="triangulationMergeMaxReprojectionError">Triangulation-time gate (pixels) for MERGING near-duplicate 3D points (triangulation.merge_max_reproj_error). Lower → fewer merges; higher → more aggressive deduplication..</param>
        /// <param name="mapperFilterMaxReprojectionError">Mapper-level **post-BA outlier** threshold (pixels) (mapper.filter_max_reproj_error). Points exceeding this after local/global BA are culled. This is NOT a triangulation accept threshold..</param>
        /// <param name="bundleAdjustmentRefineSensorFromRig">If true, refine per-camera extrinsics within the rig during BA (ba_refine_sensor_from_rig). Useful when rig calibration is approximate..</param>
        /// <param name="bundleAdjustmentRefineFocalLength">If true, refine the camera focal length during BA (ba_refine_focal_length)..</param>
        /// <param name="bundleAdjustmentRefinePrincipalPoint">If true, refine the camera principal point during BA (ba_refine_principal_point)..</param>
        /// <param name="bundleAdjustmentRefineAdditionalParams">If true, refine model-specific additional parameters during BA (ba_refine_extra_params), e.g., radial/tangential distortion where applicable..</param>
        /// <param name="compressionOpqNumberOfSubvectors">Number of subvectors for OPQ compression..</param>
        /// <param name="compressionOpqNumberOfBitsPerSubvector">Number of bits per subvector for OPQ compression..</param>
        /// <param name="compressionOpqNumberOfTrainingIterations">Number of training iterations for OPQ compression..</param>
        /// <param name="posePriorPositionSigmaM">Standard deviation (meters) for position priors when writing PosePrior to the database. Smaller values &#x3D; stronger priors..</param>
        public ReconstructionOptions()
        {
        }

        /// <summary>
        /// Random seed to use (for deterministic behavior).
        /// </summary>
        /// <value>Random seed to use (for deterministic behavior).</value>
        [DataMember(Name = "random_seed", EmitDefaultValue = true)]
        public int? RandomSeed
        {
            get{ return _RandomSeed;}
            set
            {
                _RandomSeed = value;
                _flagRandomSeed = true;
            }
        }
        private int? _RandomSeed;
        private bool _flagRandomSeed;

        /// <summary>
        /// Returns false as RandomSeed should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRandomSeed()
        {
            return _flagRandomSeed;
        }
        /// <summary>
        /// If true, run reconstruction in single-threaded mode (for deterministic behavior).
        /// </summary>
        /// <value>If true, run reconstruction in single-threaded mode (for deterministic behavior).</value>
        [DataMember(Name = "single_threaded", EmitDefaultValue = true)]
        public bool? SingleThreaded
        {
            get{ return _SingleThreaded;}
            set
            {
                _SingleThreaded = value;
                _flagSingleThreaded = true;
            }
        }
        private bool? _SingleThreaded;
        private bool _flagSingleThreaded;

        /// <summary>
        /// Returns false as SingleThreaded should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeSingleThreaded()
        {
            return _flagSingleThreaded;
        }
        /// <summary>
        /// How many pose-nearest neighbors to consider when generating image pairs. Use -1 for exhaustive matching (all pairs). If None, a sensible default is used (currently 12). Smaller values reduce weak overlaps and speed up matching at the cost of some coverage.
        /// </summary>
        /// <value>How many pose-nearest neighbors to consider when generating image pairs. Use -1 for exhaustive matching (all pairs). If None, a sensible default is used (currently 12). Smaller values reduce weak overlaps and speed up matching at the cost of some coverage.</value>
        [DataMember(Name = "neighbors_count", EmitDefaultValue = true)]
        public int? NeighborsCount
        {
            get{ return _NeighborsCount;}
            set
            {
                _NeighborsCount = value;
                _flagNeighborsCount = true;
            }
        }
        private int? _NeighborsCount;
        private bool _flagNeighborsCount;

        /// <summary>
        /// Returns false as NeighborsCount should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeNeighborsCount()
        {
            return _flagNeighborsCount;
        }
        /// <summary>
        /// Rotation angle threshold (degrees) for considering two images as neighbors when generating image pairs. Smaller values reduce weak overlaps and speed up matching at the cost of some coverage.
        /// </summary>
        /// <value>Rotation angle threshold (degrees) for considering two images as neighbors when generating image pairs. Smaller values reduce weak overlaps and speed up matching at the cost of some coverage.</value>
        [DataMember(Name = "rotation_threshold", EmitDefaultValue = true)]
        public double? RotationThreshold
        {
            get{ return _RotationThreshold;}
            set
            {
                _RotationThreshold = value;
                _flagRotationThreshold = true;
            }
        }
        private double? _RotationThreshold;
        private bool _flagRotationThreshold;

        /// <summary>
        /// Returns false as RotationThreshold should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRotationThreshold()
        {
            return _flagRotationThreshold;
        }
        /// <summary>
        /// Upper bound on detected local features per image (SuperPoint). Reduces descriptor/match volume and downstream 3D points; too small can hurt registration.
        /// </summary>
        /// <value>Upper bound on detected local features per image (SuperPoint). Reduces descriptor/match volume and downstream 3D points; too small can hurt registration.</value>
        [DataMember(Name = "max_keypoints_per_image", EmitDefaultValue = true)]
        public int? MaxKeypointsPerImage
        {
            get{ return _MaxKeypointsPerImage;}
            set
            {
                _MaxKeypointsPerImage = value;
                _flagMaxKeypointsPerImage = true;
            }
        }
        private int? _MaxKeypointsPerImage;
        private bool _flagMaxKeypointsPerImage;

        /// <summary>
        /// Returns false as MaxKeypointsPerImage should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMaxKeypointsPerImage()
        {
            return _flagMaxKeypointsPerImage;
        }
        /// <summary>
        /// Two-view RANSAC inlier threshold (pixels) used by verify_matches(). Lower &#x3D; stricter inlier test; removes borderline correspondences before SfM.
        /// </summary>
        /// <value>Two-view RANSAC inlier threshold (pixels) used by verify_matches(). Lower &#x3D; stricter inlier test; removes borderline correspondences before SfM.</value>
        [DataMember(Name = "ransac_max_error", EmitDefaultValue = true)]
        public double? RansacMaxError
        {
            get{ return _RansacMaxError;}
            set
            {
                _RansacMaxError = value;
                _flagRansacMaxError = true;
            }
        }
        private double? _RansacMaxError;
        private bool _flagRansacMaxError;

        /// <summary>
        /// Returns false as RansacMaxError should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRansacMaxError()
        {
            return _flagRansacMaxError;
        }
        /// <summary>
        /// Two-view RANSAC minimum inlier ratio to accept the model. Higher &#x3D; reject more weak pairs; typically 0.10–0.20 for stricter matching.
        /// </summary>
        /// <value>Two-view RANSAC minimum inlier ratio to accept the model. Higher &#x3D; reject more weak pairs; typically 0.10–0.20 for stricter matching.</value>
        [DataMember(Name = "ransac_min_inlier_ratio", EmitDefaultValue = true)]
        public double? RansacMinInlierRatio
        {
            get{ return _RansacMinInlierRatio;}
            set
            {
                _RansacMinInlierRatio = value;
                _flagRansacMinInlierRatio = true;
            }
        }
        private double? _RansacMinInlierRatio;
        private bool _flagRansacMinInlierRatio;

        /// <summary>
        /// Returns false as RansacMinInlierRatio should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRansacMinInlierRatio()
        {
            return _flagRansacMinInlierRatio;
        }
        /// <summary>
        /// If true, use position priors during registration. This leverages PosePrior(position&#x3D;...) written into the database to guide image registration.
        /// </summary>
        /// <value>If true, use position priors during registration. This leverages PosePrior(position&#x3D;...) written into the database to guide image registration.</value>
        [DataMember(Name = "use_prior_position", EmitDefaultValue = true)]
        public bool? UsePriorPosition
        {
            get{ return _UsePriorPosition;}
            set
            {
                _UsePriorPosition = value;
                _flagUsePriorPosition = true;
            }
        }
        private bool? _UsePriorPosition;
        private bool _flagUsePriorPosition;

        /// <summary>
        /// Returns false as UsePriorPosition should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeUsePriorPosition()
        {
            return _flagUsePriorPosition;
        }
        /// <summary>
        /// If true, perform rig-based verification during feature matching and two-view geometry verification. Requires images to be tagged with rig/camera IDs.
        /// </summary>
        /// <value>If true, perform rig-based verification during feature matching and two-view geometry verification. Requires images to be tagged with rig/camera IDs.</value>
        [DataMember(Name = "rig_verification", EmitDefaultValue = true)]
        public bool? RigVerification
        {
            get{ return _RigVerification;}
            set
            {
                _RigVerification = value;
                _flagRigVerification = true;
            }
        }
        private bool? _RigVerification;
        private bool _flagRigVerification;

        /// <summary>
        /// Returns false as RigVerification should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeRigVerification()
        {
            return _flagRigVerification;
        }
        /// <summary>
        /// Minimum triangulation angle (degrees). Applied at creation time (triangulation.min_angle) and again during mapper filtering (mapper.filter_min_tri_angle). Raising it removes low-parallax points.
        /// </summary>
        /// <value>Minimum triangulation angle (degrees). Applied at creation time (triangulation.min_angle) and again during mapper filtering (mapper.filter_min_tri_angle). Raising it removes low-parallax points.</value>
        [DataMember(Name = "triangulation_minimum_angle", EmitDefaultValue = true)]
        public double? TriangulationMinimumAngle
        {
            get{ return _TriangulationMinimumAngle;}
            set
            {
                _TriangulationMinimumAngle = value;
                _flagTriangulationMinimumAngle = true;
            }
        }
        private double? _TriangulationMinimumAngle;
        private bool _flagTriangulationMinimumAngle;

        /// <summary>
        /// Returns false as TriangulationMinimumAngle should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTriangulationMinimumAngle()
        {
            return _flagTriangulationMinimumAngle;
        }
        /// <summary>
        /// Triangulation-time gate (pixels) for COMPLETING tracks into new 3D points (triangulation.complete_max_reproj_error). Lower → fewer borderline new points.
        /// </summary>
        /// <value>Triangulation-time gate (pixels) for COMPLETING tracks into new 3D points (triangulation.complete_max_reproj_error). Lower → fewer borderline new points.</value>
        [DataMember(Name = "triangulation_complete_max_reprojection_error", EmitDefaultValue = true)]
        public double? TriangulationCompleteMaxReprojectionError
        {
            get{ return _TriangulationCompleteMaxReprojectionError;}
            set
            {
                _TriangulationCompleteMaxReprojectionError = value;
                _flagTriangulationCompleteMaxReprojectionError = true;
            }
        }
        private double? _TriangulationCompleteMaxReprojectionError;
        private bool _flagTriangulationCompleteMaxReprojectionError;

        /// <summary>
        /// Returns false as TriangulationCompleteMaxReprojectionError should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTriangulationCompleteMaxReprojectionError()
        {
            return _flagTriangulationCompleteMaxReprojectionError;
        }
        /// <summary>
        /// Triangulation-time gate (pixels) for MERGING near-duplicate 3D points (triangulation.merge_max_reproj_error). Lower → fewer merges; higher → more aggressive deduplication.
        /// </summary>
        /// <value>Triangulation-time gate (pixels) for MERGING near-duplicate 3D points (triangulation.merge_max_reproj_error). Lower → fewer merges; higher → more aggressive deduplication.</value>
        [DataMember(Name = "triangulation_merge_max_reprojection_error", EmitDefaultValue = true)]
        public double? TriangulationMergeMaxReprojectionError
        {
            get{ return _TriangulationMergeMaxReprojectionError;}
            set
            {
                _TriangulationMergeMaxReprojectionError = value;
                _flagTriangulationMergeMaxReprojectionError = true;
            }
        }
        private double? _TriangulationMergeMaxReprojectionError;
        private bool _flagTriangulationMergeMaxReprojectionError;

        /// <summary>
        /// Returns false as TriangulationMergeMaxReprojectionError should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTriangulationMergeMaxReprojectionError()
        {
            return _flagTriangulationMergeMaxReprojectionError;
        }
        /// <summary>
        /// Mapper-level **post-BA outlier** threshold (pixels) (mapper.filter_max_reproj_error). Points exceeding this after local/global BA are culled. This is NOT a triangulation accept threshold.
        /// </summary>
        /// <value>Mapper-level **post-BA outlier** threshold (pixels) (mapper.filter_max_reproj_error). Points exceeding this after local/global BA are culled. This is NOT a triangulation accept threshold.</value>
        [DataMember(Name = "mapper_filter_max_reprojection_error", EmitDefaultValue = true)]
        public double? MapperFilterMaxReprojectionError
        {
            get{ return _MapperFilterMaxReprojectionError;}
            set
            {
                _MapperFilterMaxReprojectionError = value;
                _flagMapperFilterMaxReprojectionError = true;
            }
        }
        private double? _MapperFilterMaxReprojectionError;
        private bool _flagMapperFilterMaxReprojectionError;

        /// <summary>
        /// Returns false as MapperFilterMaxReprojectionError should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMapperFilterMaxReprojectionError()
        {
            return _flagMapperFilterMaxReprojectionError;
        }
        /// <summary>
        /// If true, refine per-camera extrinsics within the rig during BA (ba_refine_sensor_from_rig). Useful when rig calibration is approximate.
        /// </summary>
        /// <value>If true, refine per-camera extrinsics within the rig during BA (ba_refine_sensor_from_rig). Useful when rig calibration is approximate.</value>
        [DataMember(Name = "bundle_adjustment_refine_sensor_from_rig", EmitDefaultValue = true)]
        public bool? BundleAdjustmentRefineSensorFromRig
        {
            get{ return _BundleAdjustmentRefineSensorFromRig;}
            set
            {
                _BundleAdjustmentRefineSensorFromRig = value;
                _flagBundleAdjustmentRefineSensorFromRig = true;
            }
        }
        private bool? _BundleAdjustmentRefineSensorFromRig;
        private bool _flagBundleAdjustmentRefineSensorFromRig;

        /// <summary>
        /// Returns false as BundleAdjustmentRefineSensorFromRig should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeBundleAdjustmentRefineSensorFromRig()
        {
            return _flagBundleAdjustmentRefineSensorFromRig;
        }
        /// <summary>
        /// If true, refine the camera focal length during BA (ba_refine_focal_length).
        /// </summary>
        /// <value>If true, refine the camera focal length during BA (ba_refine_focal_length).</value>
        [DataMember(Name = "bundle_adjustment_refine_focal_length", EmitDefaultValue = true)]
        public bool? BundleAdjustmentRefineFocalLength
        {
            get{ return _BundleAdjustmentRefineFocalLength;}
            set
            {
                _BundleAdjustmentRefineFocalLength = value;
                _flagBundleAdjustmentRefineFocalLength = true;
            }
        }
        private bool? _BundleAdjustmentRefineFocalLength;
        private bool _flagBundleAdjustmentRefineFocalLength;

        /// <summary>
        /// Returns false as BundleAdjustmentRefineFocalLength should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeBundleAdjustmentRefineFocalLength()
        {
            return _flagBundleAdjustmentRefineFocalLength;
        }
        /// <summary>
        /// If true, refine the camera principal point during BA (ba_refine_principal_point).
        /// </summary>
        /// <value>If true, refine the camera principal point during BA (ba_refine_principal_point).</value>
        [DataMember(Name = "bundle_adjustment_refine_principal_point", EmitDefaultValue = true)]
        public bool? BundleAdjustmentRefinePrincipalPoint
        {
            get{ return _BundleAdjustmentRefinePrincipalPoint;}
            set
            {
                _BundleAdjustmentRefinePrincipalPoint = value;
                _flagBundleAdjustmentRefinePrincipalPoint = true;
            }
        }
        private bool? _BundleAdjustmentRefinePrincipalPoint;
        private bool _flagBundleAdjustmentRefinePrincipalPoint;

        /// <summary>
        /// Returns false as BundleAdjustmentRefinePrincipalPoint should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeBundleAdjustmentRefinePrincipalPoint()
        {
            return _flagBundleAdjustmentRefinePrincipalPoint;
        }
        /// <summary>
        /// If true, refine model-specific additional parameters during BA (ba_refine_extra_params), e.g., radial/tangential distortion where applicable.
        /// </summary>
        /// <value>If true, refine model-specific additional parameters during BA (ba_refine_extra_params), e.g., radial/tangential distortion where applicable.</value>
        [DataMember(Name = "bundle_adjustment_refine_additional_params", EmitDefaultValue = true)]
        public bool? BundleAdjustmentRefineAdditionalParams
        {
            get{ return _BundleAdjustmentRefineAdditionalParams;}
            set
            {
                _BundleAdjustmentRefineAdditionalParams = value;
                _flagBundleAdjustmentRefineAdditionalParams = true;
            }
        }
        private bool? _BundleAdjustmentRefineAdditionalParams;
        private bool _flagBundleAdjustmentRefineAdditionalParams;

        /// <summary>
        /// Returns false as BundleAdjustmentRefineAdditionalParams should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeBundleAdjustmentRefineAdditionalParams()
        {
            return _flagBundleAdjustmentRefineAdditionalParams;
        }
        /// <summary>
        /// Number of subvectors for OPQ compression.
        /// </summary>
        /// <value>Number of subvectors for OPQ compression.</value>
        [DataMember(Name = "compression_opq_number_of_subvectors", EmitDefaultValue = true)]
        public int? CompressionOpqNumberOfSubvectors
        {
            get{ return _CompressionOpqNumberOfSubvectors;}
            set
            {
                _CompressionOpqNumberOfSubvectors = value;
                _flagCompressionOpqNumberOfSubvectors = true;
            }
        }
        private int? _CompressionOpqNumberOfSubvectors;
        private bool _flagCompressionOpqNumberOfSubvectors;

        /// <summary>
        /// Returns false as CompressionOpqNumberOfSubvectors should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCompressionOpqNumberOfSubvectors()
        {
            return _flagCompressionOpqNumberOfSubvectors;
        }
        /// <summary>
        /// Number of bits per subvector for OPQ compression.
        /// </summary>
        /// <value>Number of bits per subvector for OPQ compression.</value>
        [DataMember(Name = "compression_opq_number_of_bits_per_subvector", EmitDefaultValue = true)]
        public int? CompressionOpqNumberOfBitsPerSubvector
        {
            get{ return _CompressionOpqNumberOfBitsPerSubvector;}
            set
            {
                _CompressionOpqNumberOfBitsPerSubvector = value;
                _flagCompressionOpqNumberOfBitsPerSubvector = true;
            }
        }
        private int? _CompressionOpqNumberOfBitsPerSubvector;
        private bool _flagCompressionOpqNumberOfBitsPerSubvector;

        /// <summary>
        /// Returns false as CompressionOpqNumberOfBitsPerSubvector should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCompressionOpqNumberOfBitsPerSubvector()
        {
            return _flagCompressionOpqNumberOfBitsPerSubvector;
        }
        /// <summary>
        /// Number of training iterations for OPQ compression.
        /// </summary>
        /// <value>Number of training iterations for OPQ compression.</value>
        [DataMember(Name = "compression_opq_number_of_training_iterations", EmitDefaultValue = true)]
        public int? CompressionOpqNumberOfTrainingIterations
        {
            get{ return _CompressionOpqNumberOfTrainingIterations;}
            set
            {
                _CompressionOpqNumberOfTrainingIterations = value;
                _flagCompressionOpqNumberOfTrainingIterations = true;
            }
        }
        private int? _CompressionOpqNumberOfTrainingIterations;
        private bool _flagCompressionOpqNumberOfTrainingIterations;

        /// <summary>
        /// Returns false as CompressionOpqNumberOfTrainingIterations should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCompressionOpqNumberOfTrainingIterations()
        {
            return _flagCompressionOpqNumberOfTrainingIterations;
        }
        /// <summary>
        /// Standard deviation (meters) for position priors when writing PosePrior to the database. Smaller values &#x3D; stronger priors.
        /// </summary>
        /// <value>Standard deviation (meters) for position priors when writing PosePrior to the database. Smaller values &#x3D; stronger priors.</value>
        [DataMember(Name = "pose_prior_position_sigma_m", EmitDefaultValue = true)]
        public double? PosePriorPositionSigmaM
        {
            get{ return _PosePriorPositionSigmaM;}
            set
            {
                _PosePriorPositionSigmaM = value;
                _flagPosePriorPositionSigmaM = true;
            }
        }
        private double? _PosePriorPositionSigmaM;
        private bool _flagPosePriorPositionSigmaM;

        /// <summary>
        /// Returns false as PosePriorPositionSigmaM should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePosePriorPositionSigmaM()
        {
            return _flagPosePriorPositionSigmaM;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReconstructionOptions {\n");
            sb.Append("  RandomSeed: ").Append(RandomSeed).Append("\n");
            sb.Append("  SingleThreaded: ").Append(SingleThreaded).Append("\n");
            sb.Append("  NeighborsCount: ").Append(NeighborsCount).Append("\n");
            sb.Append("  RotationThreshold: ").Append(RotationThreshold).Append("\n");
            sb.Append("  MaxKeypointsPerImage: ").Append(MaxKeypointsPerImage).Append("\n");
            sb.Append("  RansacMaxError: ").Append(RansacMaxError).Append("\n");
            sb.Append("  RansacMinInlierRatio: ").Append(RansacMinInlierRatio).Append("\n");
            sb.Append("  UsePriorPosition: ").Append(UsePriorPosition).Append("\n");
            sb.Append("  RigVerification: ").Append(RigVerification).Append("\n");
            sb.Append("  TriangulationMinimumAngle: ").Append(TriangulationMinimumAngle).Append("\n");
            sb.Append("  TriangulationCompleteMaxReprojectionError: ").Append(TriangulationCompleteMaxReprojectionError).Append("\n");
            sb.Append("  TriangulationMergeMaxReprojectionError: ").Append(TriangulationMergeMaxReprojectionError).Append("\n");
            sb.Append("  MapperFilterMaxReprojectionError: ").Append(MapperFilterMaxReprojectionError).Append("\n");
            sb.Append("  BundleAdjustmentRefineSensorFromRig: ").Append(BundleAdjustmentRefineSensorFromRig).Append("\n");
            sb.Append("  BundleAdjustmentRefineFocalLength: ").Append(BundleAdjustmentRefineFocalLength).Append("\n");
            sb.Append("  BundleAdjustmentRefinePrincipalPoint: ").Append(BundleAdjustmentRefinePrincipalPoint).Append("\n");
            sb.Append("  BundleAdjustmentRefineAdditionalParams: ").Append(BundleAdjustmentRefineAdditionalParams).Append("\n");
            sb.Append("  CompressionOpqNumberOfSubvectors: ").Append(CompressionOpqNumberOfSubvectors).Append("\n");
            sb.Append("  CompressionOpqNumberOfBitsPerSubvector: ").Append(CompressionOpqNumberOfBitsPerSubvector).Append("\n");
            sb.Append("  CompressionOpqNumberOfTrainingIterations: ").Append(CompressionOpqNumberOfTrainingIterations).Append("\n");
            sb.Append("  PosePriorPositionSigmaM: ").Append(PosePriorPositionSigmaM).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

    }

}
